{"meta":{"title":"Emmroll's Blog","subtitle":"星光不问赶路人，时光不负有心人","description":null,"author":"孙彰冰","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"JavaScript的一些基础知识对象以及内置对象的常用方法","slug":"JavaScript对象","date":"2019-09-20T03:26:46.000Z","updated":"2019-09-24T13:45:56.171Z","comments":true,"path":"2019/09/20/JavaScript对象/","link":"","permalink":"http://yoursite.com/2019/09/20/JavaScript对象/","excerpt":"面向过程：凡事都要亲力亲为，每件事的具体过程都要知道，注重的是过程。","text":"面向过程：凡事都要亲力亲为，每件事的具体过程都要知道，注重的是过程。 面向对象：根据需求找对象，所有的事都用对象来做，注重的是结果。 面向对象的特性：封装，继承，多态（抽象性） js不是面向对象的语言，但是可以模拟面向对象的思想。 js是一门基于对象的语言。 对象：有特征和行为。（特征-&gt;属性，行为-&gt;方法。) 在当前这个对象的方法中是可以访问当前这个对象的属性的值 this代表当前对象### ###创建对象的方法（三种方式） 一、 调用系统的构造函数创建对象 var 变量名 = new Object();//Object是系统的构造函数 例子： var obj=new Object(); //添加属性：对象.属性名=值 obj.name=&quot;小明&quot;; obj.age=18; obj.sex=&quot;男&quot;; //添加方法：对象.方法名=函数 obj.eat=function(){console.log(&quot;今天吃了蛋炒饭&quot;)}; obj.play=function(){console.log(&quot;今天玩了过家家&quot;)}; //使用 console.log(obj.name); console.log(obj.sex); console.log(obj.age); obj.eat(); obj.play();二、 自定义构造函数创建对象（结合第一种和需求通过工厂模式创建对象） 首先，了解一下工厂模式创建对象：如何一次性创建多个对象？答：把创建对象的代码封装在一个函数中，多次使用多次调用。 function createObject(name,age){ var obj=new Object();//创建对象 obj.name=name; obj.age=age; obj.sayHi=function(){console.log(&quot;hello，我叫&quot;+this.name+&quot;今年&quot;+this.age+&quot;岁&quot;); }; return obj; } //创建人的对象 var per1=createObject(“小芳”,30); per1.sayHi(); //创建第二个人的对象 var per2=createObject(&quot;小丽&quot;,40); per2.sayHi()下面就是自定义构造函数创建对象的方法： 例子： //先定义一个构造函数 function Person(name,age){ this.name=name; this.age=age; this.sayHi=function(){console.log(&quot;我是&quot;+this.name+&quot;年龄&quot;+this.age); }; //创建对象---实例化一个对象并初始化 var obj=new Person(&quot;小明&quot;,18); console.log(obj.name); console.log(obj.age); obj.sayHi(); var obj2....知识点：var obj=new Person(“小明”,18);这行代码执行的时候，发生了四件事（系统做的） 在内存中开辟空间申请（一块空闲的空间），存储创建新的对象 把this设置为当前的对象 设置对象的属性和方法的值 把this这个对象返回 三、字面量的方式创建对象 var obj2={ name: &quot;小明&quot;, age: 20, sayHi: function(){ console.log(&quot;我是&quot;+this.name); } }; obj2.sayHi();字面量构造函数的缺陷：一次性的对象 关于对象的一些知识点 如何获取该变量（对象）是不是属于什么类型的？ 语法：变量 instanceof 类型的名字 true--是的 false--不是的 调用系统构造函数创建对象不能分辨出对象到底是属于什么类型的(都是Object) 函数和构造函数的区别，名字是大写是构造函数，写构造函数是为了创建对象，普通函数是为了调用 对象占有两块空间，一块是堆，一块是栈。栈里存的是该对象所在空间的地址（引用） 访问对象中的属性，除了点方法，还有别的 obj.name=&quot;佐助&quot;=====obj[&quot;name&quot;]=&quot;佐助&quot; obj.play()====obj[&quot;play&quot;] JSON数据的格式以及遍历JSON格式的数据：一般是成对的，是键值对 json也是一个对象，数据都是成对的，一般json格式的数据无论是键还是值都是用双引号括起来的。 var json={ &quot;name&quot;:&quot;小明&quot;, &quot;age&quot;:&quot;10&quot;, &quot;sex&quot;:&quot;男&quot; };遍历对象，是不能通过for循环遍历 将json对象中的数据一个一个的遍历出来： for(var key in json){console.log(key);//json对象中的属性的名字 console.log(json.key);}js学习中的三种对象1.内置对象（js系统自带的对象） 2.自定义对象（自己定义的构造函数创建的对象） 3.浏览器对象（BOM的时候讲） ####内置对象（Math,Date,String,Array,Object） MDN—-在线的帮助文档 Math对象 Math.abs(值)—-绝对值 Math.ceil(值)—向上取整 Math.floor(值)—向下取整 Math.fround(值)—变成小数 Math.max(值，值,…)—-找出最大值 Math.pow(x,y)—得出x的y次方 Math.sqrt(值)—找出一个数的平方根 Math.random(值)–得到的是0到1之间的随机数 parseInt(Math.random()*5)+1)—得到的是1-5之间的随机数 Math.abs(null);//0 Math.abs(“string”);//NaN Date对象 var dt = new Date();//当前服务器的时间 var dt = new Date(“2019.09.24”);//传入的时间（传入是字符串类型，得到时间类型） var dt = Date.now();//从1970到现在的毫秒数 var dt = new Date(); 获取年份：dt.getFullYear() 获取月份: dt.getMonth();—是从0开始的，真实的月份要加1 获取日期：dt.getDate(); 获取小时：dt.getHours(); 获取分钟：dt.getMinutes(); 获取秒： dt.getSeconds(); 获取星期：dt.getDays();—从0开始的 String对象 string -&gt;字符串类型–基本类型 String -&gt;字符串类型–引用类型 小写的string是一种数据类型 大写的String是对象 str=”hello”;—可以看成一个数组，所以可以通过for循环进行遍历。 字符串不可变性：字符串的值是不能改变的 如： var str=”hello” str[1]=”w”; console.log(str);//hello 字符串常用属性 .length–字符串的长度 .charAt()–返回值是指定索引位置的字符串，超出索引返回空字符串 .fromCharCode(数字值，可以是多个参数)，返回是ASCII码对应的值。 .concat(字符串1,字符串2,…);返回的是新的字符串 .indexOf(要找的字符串,[从某个位置开始找]);得到要要的字符串的索引值，没有就返回-1 .lastIndexOf(要找的字符串);从后向前找，得到索引值，没有的话返回-1 .replace(“原来的字符串”，”新的字符串”); 字符串常用方法 .slice(开始的索引,结束的索引);从开始索引的位置开始提取，到索引为结束索引的前一个结束，没由结束的那个索引，并返回提取后的字符串，原字符串不变（不可变性） .split(“要干掉的字符串，切割后留下来的个数”);切割字符串 .substr(开始的位置，个数);截取字符串，返回的是截取后的新的字符串 .substring(开始索引，结束索引)；截取字符串，返回截取后字符串，不包含结束索引的 .toLocaleLowerCase()转小写 .toLowerCase()转小写 .toLocaleUpperCase()转大写 .toUpperCase()转大写 .trim();干掉字符串两端的空格 Array对象 Array.isAray(对象);判断这个对象是不是数组 instanceof关键字 .concat(数组，数组，…)组合成一个新数组 .every(函数);返回值是布尔类型，函数作为参数使用，函数中有三个参数，第一个参数是元素的值，第二个参数是索引值，第三个参数是原来的数组（没用） 如果这个数组中的每个元素的值都符合条件，最后才返回的是true。 .filter(函数);返回的是数组中每一个元素都符合的元素，组成一个新数组。 .push(值);把值追加到数组中，返回值是追加数据后的数组 .pop(值);删除数组中最后的元素，返回值就是删除的元素的值。 .unshift();把值追加到数组的前面，返回值是插入数据后的数组长度 .shift();删除数组的第一个元素，返回值就是删除的这个值 .forEach(函数);遍历数组用，相当于for循环 .indexOf(元素值);返回的是索引，没有则是-1 .join(“字符串”);返回的是一个字符串 .map(函数);数组中的每个元素都要执行这个函数，把执行后的结果全部放在一个数组中 .reverse();反转数组 .sort();排序的，可能不稳定，如果不稳定，请写MDN固定代码 .slice(开始的索引，结束的索引)把截取后数组值放入新数组，但是不包含结束索引元素的值 .splice(开始的位置，要删除的个数，替换的元素的值);一般是用于删除数组中的元素，或者是替换元素，或者是插入元素 知识点： 实例对象：通过构造函数创建出来的，实例化的对象 静态对象：不需要创建，直接就是一个对象，方法（静态方法）直接通过这个对象名字调用 实例方法必须通过实例对象调用 静态方法必须通过大写的对象调用","categories":[],"tags":[{"name":"对象","slug":"对象","permalink":"http://yoursite.com/tags/对象/"}]},{"title":"JavaScript中的函数基础","slug":"JavaScript函数","date":"2019-09-20T03:26:36.000Z","updated":"2019-09-24T13:46:10.866Z","comments":true,"path":"2019/09/20/JavaScript函数/","link":"","permalink":"http://yoursite.com/2019/09/20/JavaScript函数/","excerpt":"###函数：把一坨重复的代码封装，在需要的时候直接调用即可。","text":"###函数：把一坨重复的代码封装，在需要的时候直接调用即可。 命名函数：函数有名字 function f1(){} 匿名函数：函数没有名字 function (){} 函数知识点 函数的作用：代码的重用 函数的用法：函数需要先定义，然后才能使用 函数名字定义规则：遵循驼峰命名法 函数参数：在函数定义的时候，函数名字后面的小括号里的变量就是参数，目的是函数在调用的时候，用用户传进来的值操作。 此时函数定义的时候后面的小括号里面的变量就叫参数，写了两个变量，就有两个参数。 **形参：**函数在定义的时候小括号里的变量叫形参 **实参：**函数在调用的时候，小括号里传入的值叫实参，实参可以是变量也可以是数字。 **在函数调用的时候，按照提示的方式，给变量赋值---就叫传值，就把这个值传到了变量（参数）中。** 函数的返回值：在函数内部有return关键字，并且在关键字后面有内容，这个内容被返回了。当函数调用之后，需要这个返回值，那么就定义变量接收，即可（如果一个函数中有return，那么这个函数就有返回值。） 函数一旦重名，后面的会把前面的函数覆盖 一个函数最好就只有单一的功能 输出函数名—代表输出这个函数的代码 arguments对象伪数组，使用arguments可以获取传入的每个参数的值 function f1(){ //arguments—当做数组使用（伪数组） var sum=0; for(var i=0;i&lt;arguments.length;i++){ sum+=arguments[i]; } return sum; } console.log(f1(10,20,30,40)); 如何获取某个变量的类型：typeof 函数是有数据类型的，数据类型是function类型的。 函数的其他的定义方式：函数表达式： 把一个函数给一个变量，此时形成了函数表达式 用法： var 变量=匿名函数; var f1=function(){};如果是函数表达式，那么此时前面的变量中存储的就是一个函数，而这个变量就相当于一个函数，就可以直接加小括号调用了； f1();注意：函数表达式的后面，赋值结束后，要加分号。 函数的自调用，没有名字，声明的同时，直接调用（一次性的—–只能用一次） (function(){console.log(&quot;哈哈哈哈&quot;);})()函数的使用 函数作为参数使用，如果一个函数作为参数，那么我们说这个参数（函数）可以叫回调函数。只要是看到一个函数作为参数使用，就可以把这个函数叫做回调函数。 函数声明,fn是变量，是参数 function f1(fn){ fn();//函数调用---说明fn这个变量中存储的是一个函数 } function f2(){ console.log(&quot;这也可以&quot;); } f1(f2)`2、 函数作为返回值使用 function f1(){ return function(){ console.log(&quot;这是一个函数&quot;); }; } var ff=f1();//调用ff就是一个函数，直接调用ff() 作用域：使用范围 全局变量：声明的变量是使用var声明的，这个变量就是全局变量，全局变量可以全局在页面的任何位置使用。目前除了函数之外，其他的任何位置定义的变量都是全局变量。 局部变量：在函数内部定义的变量，是局部变量，外面不能使用。 全局变量，如果页面不关闭，就不会关闭，就会占空间，消耗内存。 全局作用域：全局变量的使用范围 局部作用域：局部变量的使用范围 块级作用域：一对大括号可以看成是一块，在这块区域中定义的变量，只能在这个区域使用，但是在js中在这个块级作用域定义的变量，外面也能使用。。 说明:js没有块级作用域，只有函数除外 隐式全局变量：声明的变量，没有var，就叫隐式全局变量。 全局变量是不能被删除的，但是隐式全局变量是可以被删除的。 定义变量使用var时不会被删除的，没有var是可以被删除的。 function f1(){ number=1000;//隐式全局变量 } f1(); console.log(number);**作用域链：** var num=10; function f1(){ var num=20; function f2(){ var num=30; function f3(){ var num=50; console.log(num); } f3(); } f2(); } f1();预解析：提前解析代码 预解析的过程：1.把变量的声明提升到当前作用域的最前面，只提升声明，不会提升赋值；2.把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用3.先提升var 再提升function预解析中，变量的提升，只会在当前的作用域中提升，提升到当前的作用域的最上面函数中的变量只会提前到函数的作用域的最前面，不会出去。预解析会分段（多对的script标签中函数重名，预解析的时候不会中途） console.log(num);//没有报错 var num=10;","categories":[],"tags":[{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}]},{"title":"JavaScript数组基础","slug":"JavaScript数组","date":"2019-09-20T03:26:26.000Z","updated":"2019-09-24T13:46:25.763Z","comments":true,"path":"2019/09/20/JavaScript数组/","link":"","permalink":"http://yoursite.com/2019/09/20/JavaScript数组/","excerpt":"基础概念 数组：存储一组有序的数据 数组元素：数组中存储的每个数据，都可以叫数组的元素，比如存储了三个数据，那么数组中就有三个元素。 数组长度： 就是数组的元素的个数，比如有三个元素，就说，这个数组的长度是三。 数组索引（下标）用来存储或者访问数组中的数据的，索引从0开始，到长度减1结束 数组的索引和数组长度之间的关系：长度减1就是最大的索引值 数组长度：arr.length 如何设置数组中某个位置的值—数组名[下标]=值—arr[3]=100 如果获取数组中某个位置的值—var result=数组名[下标]–console.log(result) 数组的作用：可以一次性存储多个数据 数组的定义（两种方法）","text":"基础概念 数组：存储一组有序的数据 数组元素：数组中存储的每个数据，都可以叫数组的元素，比如存储了三个数据，那么数组中就有三个元素。 数组长度： 就是数组的元素的个数，比如有三个元素，就说，这个数组的长度是三。 数组索引（下标）用来存储或者访问数组中的数据的，索引从0开始，到长度减1结束 数组的索引和数组长度之间的关系：长度减1就是最大的索引值 数组长度：arr.length 如何设置数组中某个位置的值—数组名[下标]=值—arr[3]=100 如果获取数组中某个位置的值—var result=数组名[下标]–console.log(result) 数组的作用：可以一次性存储多个数据 数组的定义（两种方法） 1、 通过构造函数创建数组语法：var 数组名 = new Array(); var array = new Array();//定义了一个新数组 console.log(array);//数组的名字如果直接输出，那么直接就可以把数组中的数据显示出来，如果没有数据，就看不到数据。 如果数组中没有数据，但是有长度，数组中的每个值就是undefined 构造函数的方式创建数组的时候，如果在Array(一个数字)—&gt;数组的长度 如果在Array(多个值);这个数组中就有数据了，数组的长度为数据的个数 2、 通过字面量的方式创建数组（更简单） var 数组名=[];//空数组 var arrar=[]; 无论是构造函数的方式还是字面量的方式，定义的数组，如果有长度，那么默认是Undefined. ####数组的注意问题1.数组中存储的数据类型可以不一样，但是数组一般存储一样类型的数据 var arr=[10,”哈哈”,true,null,undefined,new Object()] 2.数组的长度是可以改变的 var arr=[] //通过设置索引来设置数组中元素的值 arr[0]=10 console.log(arr.length)","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"CSS浮动","slug":"CSS浮动","date":"2019-09-20T01:48:24.000Z","updated":"2019-09-20T03:21:26.370Z","comments":true,"path":"2019/09/20/CSS浮动/","link":"","permalink":"http://yoursite.com/2019/09/20/CSS浮动/","excerpt":"CSS的定位机制有三种：标准流、浮动和定位","text":"CSS的定位机制有三种：标准流、浮动和定位标准流：一个网页内标签元素从上至下，从左至右顺序排列，块级元素独占一行，行内元素按顺序依次前后排列，这种大前提的布局排列之下绝对不会出现例外的情况叫做标准流布局。 元素的浮动： 是指设置了浮动属性的元素会脱离标准流的控制，移动到父元素中指定位置的过程。在CSS中，通过float定义浮动。语法格式为：选择器{float: 属性值;} 属性值有： 浮动的目的：让多个块级元素在一行显示，方便布局。 浮动的特性：浮动脱离标准流（脱标），不占位置，会影响标准流。 1.浮动首先创建包含块的概念，就是说，浮动的元素总是找它最近的父元素对齐，但是不会超过内边距的范围。示例代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father { width: 600px; height: 600px; background-color: skyblue; padding: 100px; } .son { width: 200px; height: 200px; background-color: deeppink; float: right; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;结果显示： #####2.浮动的元素排列位置：跟上一个元素（块级）有关系，如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐，如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。注意：一个父盒子里面的子盒子，如果其中的一个子级有浮动，则其他子级都需要浮动，这样才能一行对齐显示。 #####3、模式转换（浮动可以让元素默认转换为行内块）元素添加浮动之后，元素会具有行内块元素的特性，元素的大小会取决于定义的大小或者默认的内容多少。(妙用:如果已经给行内元素添加了浮动，此时不需要转换了这个元素也可以有宽高)例子： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div { height: 100px; background-color: skyblue; float: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;你好，浮动&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;效果：","categories":[],"tags":[{"name":"CSS浮动","slug":"CSS浮动","permalink":"http://yoursite.com/tags/CSS浮动/"}]},{"title":"CSS定位","slug":"CSS定位","date":"2019-09-18T15:21:52.000Z","updated":"2019-09-19T06:37:58.653Z","comments":true,"path":"2019/09/18/CSS定位/","link":"","permalink":"http://yoursite.com/2019/09/18/CSS定位/","excerpt":"在CSS中,position属性用于定义元素的定位模式，语法为选择器{position: 属性值}position属性的常用值：","text":"在CSS中,position属性用于定义元素的定位模式，语法为选择器{position: 属性值}position属性的常用值： 一、静态定位—所有元素的默认定位方式，position取值为static.静态定位唯一的用处就是来取消定位。####二、相对定位—将元素相对于它在标准流中的位置进行定位，position取值为relative.对元素进行相对定位之后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留。 注意： 相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。 其次，每次移动的位置，是以自己的左上角为基点移动（相对于自己来移动位置）就是说，相对定位盒子仍在标准流中，它后面的盒子仍以标准流方式对待它.(相对定位不脱标)如果说浮动的主要目的是，让多个块级元素在一行显示，那么定位的主要价值是移动位置，让盒子到我们想要的位置上去。 例子：说明了相对定位与浮动的不同之处，上面的盒子相对定位浮动了，但是原来的位置还在，所以下面的盒子也还在原地。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div { width: 200px; height: 200px; background-color: pink; } .top { position: relative; top: 100px; left: 100px; } .bottom { background-color: purple; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;结果： 三、绝对定位—position属性值为absolute。绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置 例子： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div { width: 200px; height: 200px; background-color: pink; } .top { position: absolute; } .bottom { background-color: purple; width: 210px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;结果： 父级没有定位或者没有父元素（此时父元素是body）若所有的父元素都没有定位，以浏览器当前屏幕为准对齐（document文档)。 例子： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div { width: 200px; height: 200px; background-color: pink; } .top { position: absolute; right: 0; bottom: 0; } .bottom { background-color: purple; width: 210px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;结果： 2.父亲有定位绝对定位将元素根据最近的已经定位（绝对、固定或者相对定位）的父元素（祖先）进行定位。 例子 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father { width: 500px; height: 500px; background-color: pink; margin: 100px; position: relative; } .son { width: 200px; height: 200px; background-color: purple; position: absolute; left: 50px; top: 50px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;结果： 子绝父相： 子级是绝对定位的话，父亲要用相对定位。很有用的准则！！！ 绝对定位的盒子水平/垂直居中普通的盒子左右margin改为auto就可以了，但是对于绝对定位就无效了。定位的盒子也可以水平或者垂直居中，有一个算法。 首先left：50%，父盒子一半的大小。 然后走自己外边距负的一般值就可以了margin-left &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div { width: 200px; height: 200px; background-color: pink; position: absolute; /*margin: 0 auto;*/ /*加了定位和浮动的盒子margin: 0 auto;就失效了*/ left: 50%; margin-left: -100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 四、固定定位fixed固定定位是绝对定位的一种特殊形式，类似于正方形是一个特殊的矩形，它以浏览器窗口作为参照物来定义网页元素，当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。 当对元素设置固定定位之后，它将脱离标准文档流的控制，时钟依据浏览器窗口来定义自己的显示位置，不管浏览器滚动条如何滚动也不管浏览器的窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。 固定定位有两点： 固定定位的元素跟父亲没有任何的关系，只认浏览器。 固定定位完全脱标，不占有位置，不随着滚动条滚动。 ####五、定位模式转换 元素添加和绝对定位和固定定位之后，元素模式也会发生转换，都转为行内块模式。行内块的宽度和高度和内容有关系。因此，比如行内元素 如果添加了绝对定位或者固定定位或者浮动之后，可以不用转换模式，直接给宽度和高度即可。","categories":[],"tags":[{"name":"定位的分类","slug":"定位的分类","permalink":"http://yoursite.com/tags/定位的分类/"}]},{"title":"CSS几种元素的分类及区别","slug":"CSS几种元素分类及区别","date":"2019-09-17T15:11:06.000Z","updated":"2019-09-18T02:15:39.284Z","comments":true,"path":"2019/09/17/CSS几种元素分类及区别/","link":"","permalink":"http://yoursite.com/2019/09/17/CSS几种元素分类及区别/","excerpt":"1. inline(行内元素)","text":"1. inline(行内元素)inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列放不下才会新换一行，其宽度随元素的内容而变化。 注： inline元素设置width,height属性无效； 水平方向的padding-left,padding-right,margin-left,margin-right都产生边距效果； 竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。 常见inline元素：a,span,br,i,em,strong,label,q,var,cite,code 2.block(块级元素)block元素独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度会自动填满其父元素宽度。 注： block元素可以设置height,width属性。 块级元素即使设置了宽度，仍然是独占一行。 block元素也可以设置padding和margin属性。 常见block元素：p，div,p,h1…h6,ol,ul,dl,table,address,blockquote,form 3.inline-block(行内块元素)简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。 比如我们可以给一个link(a元素)inline-block属性值，使其既有block的宽度高度特性又具有inline的同行特性。 常见inline-block元素：img,input","categories":[],"tags":[{"name":"inline,block,inline-block","slug":"inline-block-inline-block","permalink":"http://yoursite.com/tags/inline-block-inline-block/"}]},{"title":"TCP-UDP","slug":"TCP-UDP","date":"2019-09-16T11:19:42.000Z","updated":"2019-09-16T13:09:13.487Z","comments":true,"path":"2019/09/16/TCP-UDP/","link":"","permalink":"http://yoursite.com/2019/09/16/TCP-UDP/","excerpt":"TCP和UDP是传输层的两个协议","text":"TCP和UDP是传输层的两个协议 区别：1.TCP是面对连接的，UDP是面对无连接的（发送数据之前不需要先建立连接) Q:什么是面向连接，什么是面向无连接？ A:在互通之前，面向连接的协议会先建立连接，如TCP有三次握手，而UDP没有。** 2. TCP提供可靠的服务，而UDP是不可靠的。 Q: TCP为什么是可靠连接？ A：通过TCP连接传输的数据无差错、不丢失、不重复且按顺序到达。 TCP报文头里的序号能使TCP数据按序到达。 报文头里面的确认序号能保证不丢包，累计确认及超时重传机制。 TCP拥有流量控制及拥塞控制的机制。 3. TCP面向字节流，UDP面向报文。4. TCP只能一对一，UDP支持1对1，1对多。5. TCP的首部较大为20字节，而UDP只有8字节。TCP的三次握手在TCP/IP协议中，TCP协议提供可靠的链接服务，采用三次握手来建立一个连接。 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 TCP四次挥手","categories":[],"tags":[]},{"title":"前端知识之HTTP、HTML...","slug":"http-https","date":"2019-09-14T03:52:12.000Z","updated":"2019-09-15T13:14:11.016Z","comments":true,"path":"2019/09/14/http-https/","link":"","permalink":"http://yoursite.com/2019/09/14/http-https/","excerpt":"HTTP与HTTPS 基本概念","text":"HTTP与HTTPS 基本概念 HTTP是超文本传输协议，用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTPS就是HTTP的安全版，在HTTP下加入SSL层（安全套阶层），主要作用是建立一个信息安全通道，来确保数据的传输，确保网站的真实性。 区别 *HTTPS协议需要ca证书，费用较高。 *HTTP是明文传输，HTTPS则是具有安全性的SSL加密传输协议。 *HTTP协议的端口为80，HTTPS的端口为443. *HTTPS比HTTP安全。 HTTPS工作原理 1.客户使用HTTPS url访问服务器，则要求web服务器建立SSL连接。 2.WEB服务器接收到客户端的请求之后，会将网站证书（证书中包含了公钥），或者说传输给用户。 3.客户端和WEB服务器端开始协商SSL连接的安全等级。 4.客户端浏览器通过协商好的安全等级，建立会话密钥，通过网络公钥来加密会话密钥，并传输给网站。 5.WEB服务器通过自己的私钥解密出会话密钥。 6.WEB服务器通过会话密钥加密与客户端之间通信。","categories":[],"tags":[]}]}